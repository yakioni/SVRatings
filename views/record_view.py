import discord
from discord.ui import View, Button, Select, Modal, InputText
import asyncio
from typing import List, Optional, Dict
from sqlalchemy import desc
from models.user import UserModel
from models.season import SeasonModel
from models.match import MatchModel
import logging

class CurrentSeasonRecordView(View):
    """ÁèæÂú®„Ç∑„Éº„Ç∫„É≥„ÅÆÊà¶Á∏æË°®Á§∫View"""
    
    def __init__(self):
        super().__init__(timeout=None)
        
        # Êó¢Â≠ò„ÅÆÁèæÂú®„Ç∑„Éº„Ç∫„É≥„Éú„Çø„É≥
        current_season_button = Button(label="BO1Âçò‰ΩçÊà¶Á∏æ", style=discord.ButtonStyle.primary)
        async def current_season_callback(interaction):
            await self.show_class_select(interaction)
        current_season_button.callback = current_season_callback
        self.add_item(current_season_button)
        
        # Êñ∞„Åó„ÅÑÁõ¥Ëøë50Êà¶„Éú„Çø„É≥„ÇíËøΩÂä†Ôºà„É¶„Éº„Ç∂„ÉºÊ§úÁ¥¢„Éú„Çø„É≥„Å®ÁΩÆ„ÅçÊèõ„ÅàÔºâ
        last50_button = Button(label="Áõ¥Ëøë50Êà¶", style=discord.ButtonStyle.secondary, emoji="üìã")
        async def last50_callback(interaction):
            await self.show_last50_matches(interaction)
        last50_button.callback = last50_callback
        self.add_item(last50_button)
    
    async def show_class_select(self, interaction: discord.Interaction):
        """ÈÄöÂ∏∏„ÅÆ„ÇØ„É©„ÇπÈÅ∏Êäû„ÇíË°®Á§∫"""
        user_model = UserModel()
        user = user_model.get_user_by_discord_id(str(interaction.user.id))
        
        if user and not user['latest_season_matched']:
            await interaction.response.send_message("Êú™ÂèÇÂä†„Åß„Åô", ephemeral=True)
            return
        
        season_model = SeasonModel()
        season = season_model.get_current_season()
        
        if season:
            await interaction.response.send_message(
                content="„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö", 
                view=RecordClassSelectView(season_id=season.id), 
                ephemeral=True
            )
        else:
            await interaction.response.send_message("„Ç∑„Éº„Ç∫„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
    
    async def show_last50_matches(self, interaction: discord.Interaction):
        try:
            await interaction.response.defer(ephemeral=True)
            
            # „É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„ÇíÂèñÂæó
            user_model = UserModel()
            user_data = user_model.get_user_by_discord_id(str(interaction.user.id))
            
            if not user_data:
                await interaction.followup.send("„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                return
            
            # user_data„ÅåËæûÊõ∏„Åã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇíÂà§ÂÆö„Åó„Å¶ÈÅ©Âàá„Å´„Ç¢„ÇØ„Çª„Çπ
            def get_attr(data, attr_name, default=None):
                if isinstance(data, dict):
                    return data.get(attr_name, default)
                else:
                    return getattr(data, attr_name, default)
            
            user_id = get_attr(user_data, 'id')
            user_name = get_attr(user_data, 'user_name')
            
            # Ë©¶ÂêàÂ±•Ê≠¥„ÇíÂèñÂæó
            match_model = MatchModel()
            matches = match_model.get_user_match_history(user_id, 50)
            
            # ÂÆå‰∫Ü„Åó„ÅüË©¶Âêà„ÅÆ„Åø„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            completed_matches = []
            for match in matches:
                if (match.get('winner_user_id') is not None and 
                    match.get('after_user1_rating') is not None and 
                    match.get('after_user2_rating') is not None):
                    completed_matches.append(match)
            
            if not completed_matches:
                await interaction.followup.send("ÂÆå‰∫Ü„Åó„ÅüË©¶ÂêàÂ±•Ê≠¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                return
            
            # ÊúÄÂàù„ÅÆ10Êà¶„ÇíË°®Á§∫
            await self.display_matches_page(interaction, completed_matches, 0, user_data)
            
        except Exception as e:
            logging.error(f"Error showing last 50 matches: {e}")
            await interaction.followup.send("Áõ¥Ëøë50Êà¶„ÅÆÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)
    
    async def display_matches_page(self, interaction: discord.Interaction, matches: List[dict], 
                                  page: int, user_data: dict):
        user_model = UserModel()
        
        def get_attr(data, attr_name, default=None):
            if isinstance(data, dict):
                return data.get(attr_name, default)
            else:
                return getattr(data, attr_name, default)
        
        user_id = get_attr(user_data, 'id')
        user_name = get_attr(user_data, 'user_name')
        
        # „Éö„Éº„Ç∏„É≥„Ç∞Ë®≠ÂÆö
        matches_per_page = 10
        start_idx = page * matches_per_page
        end_idx = min(start_idx + matches_per_page, len(matches))
        page_matches = matches[start_idx:end_idx]
        
        # Embed„Çí‰ΩúÊàê
        total_pages = (len(matches) + matches_per_page - 1) // matches_per_page
        embed = discord.Embed(
            title=f"{user_name} „ÅÆÁõ¥Ëøë50Êà¶ (Page {page + 1}/{total_pages})",
            description="ÂêÑË©¶Âêà„ÅÆ„Éú„Çø„É≥„ÇíÊäº„Åô„Å®„Åù„ÅÆÁõ∏Êâã„Å®„ÅÆÂÖ®ÂØæÊà¶Â±•Ê≠¥„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô",
            color=discord.Color.blue()
        )
        
        # View„Çí‰ΩúÊàêÔºà„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„Å®„Éû„ÉÉ„ÉÅ„Éú„Çø„É≥Ôºâ
        view = Last50MatchesView(matches, page, user_data, page_matches)
        
        # ÂêÑË©¶Âêà„ÅÆÊÉÖÂ†±„ÇíË°®Á§∫
        for i, match in enumerate(page_matches):
            if match['user1_id'] == user_id:
                opponent_data = user_model.get_user_by_id(match['user2_id'])
                user_rating_change = match.get('user1_rating_change', 0)
                after_rating = match.get('after_user1_rating')
                user_won = match['winner_user_id'] == user_id
                user_selected_class = match.get('user1_selected_class', 'Unknown')
            else:
                opponent_data = user_model.get_user_by_id(match['user1_id'])
                user_rating_change = match.get('user2_rating_change', 0)
                after_rating = match.get('after_user2_rating')
                user_won = match['winner_user_id'] == user_id
                user_selected_class = match.get('user2_selected_class', 'Unknown')
            
            if opponent_data:
                opponent_name = get_attr(opponent_data, 'user_name', 'Unknown')
                opponent_discord_id = get_attr(opponent_data, 'discord_id', None)
                
                # Discord Username „ÇíÂèñÂæó
                opponent_username = None
                if opponent_discord_id:
                    try:
                        discord_member = interaction.guild.get_member(int(opponent_discord_id))
                        if discord_member:
                            opponent_username = discord_member.name  # @username „ÅÆ usernameÈÉ®ÂàÜ
                    except (ValueError, AttributeError):
                        pass
                
                if opponent_username:
                    opponent_display = f"{opponent_name} (@{opponent_username})"
                else:
                    opponent_display = opponent_name
            else:
                opponent_display = 'Unknown'
            
            # Ë©¶ÂêàÁµêÊûú„ÅÆË°®Á§∫
            result_emoji = "üîµ" if user_won else "üî¥"
            result_text = "ÂãùÂà©" if user_won else "ÊïóÂåó"
            rating_change_str = f"{user_rating_change:+.0f}" if user_rating_change != 0 else "¬±0"
            
            # Êó•‰ªò„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
            match_date = match.get('match_date', '')
            if match_date:
                match_date = match_date[:16]
            else:
                match_date = 'Unknown'
            
            field_value = (
                f"**ÂØæÊà¶Áõ∏Êâã:** {opponent_display}\n"
                f"**ÁµêÊûú:** {result_text}\n"
                f"**‰ΩøÁî®„ÇØ„É©„Çπ:** {user_selected_class}\n"
                f"**„É¨„Éº„ÉàÂ§âÂãï:** {rating_change_str} (‚Üí {after_rating:.0f})\n"
                f"**„Éú„Çø„É≥Áï™Âè∑:** {start_idx + i + 1}"
            )
            
            embed.add_field(
                name=f"{result_emoji} {match_date}",
                value=field_value,
                inline=True
            )
        
        # „É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°„Åæ„Åü„ÅØÁ∑®ÈõÜ
        if page == 0:
            # ÂàùÂõûÈÄÅ‰ø°
            await interaction.followup.send(embed=embed, view=view, ephemeral=True)
        else:
            # „Éö„Éº„Ç∏Êõ¥Êñ∞
            await interaction.edit_original_response(embed=embed, view=view)

class Last50MatchesView(View):
    
    def __init__(self, all_matches: List[dict], current_page: int, user_data: dict, page_matches: List[dict]):
        super().__init__(timeout=600)
        self.all_matches = all_matches
        self.current_page = current_page
        self.user_data = user_data
        self.page_matches = page_matches
        
        # „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„Éú„Çø„É≥
        matches_per_page = 10
        total_pages = (len(all_matches) + matches_per_page - 1) // matches_per_page
        
        if current_page > 0:
            prev_button = Button(label="‚¨ÖÔ∏è Ââç„Å∏", style=discord.ButtonStyle.secondary, row=0)
            prev_button.callback = self.previous_page
            self.add_item(prev_button)
        
        if current_page < total_pages - 1:
            next_button = Button(label="‚û°Ô∏è Ê¨°„Å∏", style=discord.ButtonStyle.secondary, row=0)
            next_button.callback = self.next_page
            self.add_item(next_button)
        
        # ÂêÑË©¶Âêà„ÅÆ„Éú„Çø„É≥„ÇíËøΩÂä†ÔºàÊúÄÂ§ß10ÂÄãÔºâ
        start_idx = current_page * matches_per_page
        for i, match in enumerate(page_matches):
            button_num = start_idx + i + 1
            button = MatchOpponentButton(
                label=f"{button_num}Áï™",
                match_data=match,
                user_data=user_data,
                row=1 + (i // 5)  # 5ÂÄã„Åö„Å§Ë°å„ÇíÂàÜ„Åë„Çã
            )
            self.add_item(button)
    
    async def previous_page(self, interaction: discord.Interaction):
        """Ââç„ÅÆ„Éö„Éº„Ç∏„Å∏"""
        if self.current_page > 0:
            await interaction.response.defer()
            view = CurrentSeasonRecordView()
            await view.display_matches_page(interaction, self.all_matches, self.current_page - 1, self.user_data)
    
    async def next_page(self, interaction: discord.Interaction):
        """Ê¨°„ÅÆ„Éö„Éº„Ç∏„Å∏"""
        matches_per_page = 10
        total_pages = (len(self.all_matches) + matches_per_page - 1) // matches_per_page
        if self.current_page < total_pages - 1:
            await interaction.response.defer()
            view = CurrentSeasonRecordView()
            await view.display_matches_page(interaction, self.all_matches, self.current_page + 1, self.user_data)

class MatchOpponentButton(Button):
    
    def __init__(self, label: str, match_data: dict, user_data: dict, row: int):
        super().__init__(label=label, style=discord.ButtonStyle.primary, row=row)
        self.match_data = match_data
        self.user_data = user_data
        self.logger = logging.getLogger(self.__class__.__name__)
    
    async def callback(self, interaction: discord.Interaction):
        try:
            await interaction.response.defer(ephemeral=True)
            
            def get_attr(data, attr_name, default=None):
                if isinstance(data, dict):
                    return data.get(attr_name, default)
                else:
                    return getattr(data, attr_name, default)
            
            user_id = get_attr(self.user_data, 'id')
            user_name = get_attr(self.user_data, 'user_name')
            
            # ÂØæÊà¶Áõ∏Êâã„ÅÆID„ÇíÂèñÂæó
            if self.match_data['user1_id'] == user_id:
                opponent_id = self.match_data['user2_id']
            else:
                opponent_id = self.match_data['user1_id']
            
            # ÂØæÊà¶Áõ∏Êâã„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
            user_model = UserModel()
            opponent_data = user_model.get_user_by_id(opponent_id)
            
            if not opponent_data:
                await interaction.followup.send("ÂØæÊà¶Áõ∏Êâã„ÅÆÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                return
            
            opponent_name = get_attr(opponent_data, 'user_name', 'Unknown')
            opponent_discord_id = get_attr(opponent_data, 'discord_id', None)

            # Discord Username „ÇíÂèñÂæó
            opponent_username = None
            if opponent_discord_id:
                try:
                    discord_member = interaction.guild.get_member(int(opponent_discord_id))
                    if discord_member:
                        opponent_username = discord_member.name
                except (ValueError, AttributeError):
                    pass

            if opponent_username:
                opponent_display = f"{opponent_name} (@{opponent_username})"
                # „Çø„Ç§„Éà„É´„Åß„ÇÇ‰ΩøÁî®
                title = f"{user_name} vs {opponent_display}"
            else:
                opponent_display = opponent_name
                title = f"{user_name} vs {opponent_display}"

            # ÂÖ®„Ç∑„Éº„Ç∫„É≥„ÅÆÂØæÊà¶Â±•Ê≠¥„ÇíÂèñÂæó
            match_model = MatchModel()
            vs_matches = match_model.get_user_vs_user_history(user_id, opponent_id)
            
            if not vs_matches:
                await interaction.followup.send(
                    f"**{user_name}** vs **{opponent_name}** „ÅÆÂØæÊà¶Â±•Ê≠¥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
                    ephemeral=True
                )
                return
            
            # ÂÆå‰∫Ü„Åó„ÅüË©¶Âêà„ÅÆ„Åø„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            completed_matches = []
            for match in vs_matches:
                if (match.get('winner_user_id') is not None and 
                    match.get('after_user1_rating') is not None and 
                    match.get('after_user2_rating') is not None):
                    completed_matches.append(match)
            
            if not completed_matches:
                await interaction.followup.send(
                    f"**{user_name}** vs **{opponent_name}** „ÅÆÂÆå‰∫Ü„Åó„ÅüÂØæÊà¶„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
                    ephemeral=True
                )
                return
            
            # ÂãùÊïó„ÇíÈõÜË®à
            user_wins = 0
            opponent_wins = 0
            
            for match in completed_matches:
                if match['winner_user_id'] == user_id:
                    user_wins += 1
                elif match['winner_user_id'] == opponent_id:
                    opponent_wins += 1
            
            total_matches = user_wins + opponent_wins
            user_win_rate = (user_wins / total_matches) * 100
            
            # ÂØæÊà¶Â±•Ê≠¥„ÇíEmbed„ÅßË°®Á§∫
            embeds = []
            current_embed = None
            matches_per_embed = 8
            
            for i, match in enumerate(completed_matches):
                if i % matches_per_embed == 0:
                    page_num = i // matches_per_embed + 1
                    total_pages = (len(completed_matches) + matches_per_embed - 1) // matches_per_embed
                    
                    description = f"{user_wins}Âãù{opponent_wins}Êïó(ÂãùÁéá{user_win_rate:.0f}%) | Page {page_num}/{total_pages}"
                    
                    current_embed = discord.Embed(
                        title=title,
                        description=description,
                        color=discord.Color.purple()
                    )
                    embeds.append(current_embed)
                
                # „É¶„Éº„Ç∂„Éº„ÅÆË¶ñÁÇπ„ÅßÊÉÖÂ†±„ÇíÊï¥ÁêÜ
                if match['user1_id'] == user_id:
                    # „É¶„Éº„Ç∂„Éº„Ååuser1
                    user_rating_change = match.get('user1_rating_change', 0)
                    opponent_rating_change = match.get('user2_rating_change', 0)
                    user_after_rating = match.get('after_user1_rating')
                    opponent_after_rating = match.get('after_user2_rating')
                    user_won = match['winner_user_id'] == user_id
                    user_selected_class = match.get('user1_selected_class', 'Unknown')
                    opponent_selected_class = match.get('user2_selected_class', 'Unknown')
                else:
                    # „É¶„Éº„Ç∂„Éº„Ååuser2
                    user_rating_change = match.get('user2_rating_change', 0)
                    opponent_rating_change = match.get('user1_rating_change', 0)
                    user_after_rating = match.get('after_user2_rating')
                    opponent_after_rating = match.get('after_user1_rating')
                    user_won = match['winner_user_id'] == user_id
                    user_selected_class = match.get('user2_selected_class', 'Unknown')
                    opponent_selected_class = match.get('user1_selected_class', 'Unknown')
                
                # NoneÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ„Å®„Éá„Éï„Ç©„É´„ÉàÂÄ§Ë®≠ÂÆö
                if user_rating_change is None:
                    user_rating_change = 0
                if opponent_rating_change is None:
                    opponent_rating_change = 0
                if user_after_rating is None:
                    user_after_rating = 0
                if opponent_after_rating is None:
                    opponent_after_rating = 0
                
                # „ÇØ„É©„ÇπÊÉÖÂ†±„ÅÆÊï¥ÁêÜ
                if not user_selected_class:
                    user_selected_class = 'Unknown'
                if not opponent_selected_class:
                    opponent_selected_class = 'Unknown'
                
                # Ë©¶ÂêàÁµêÊûú„ÅÆË°®Á§∫
                result_emoji = "üîµ" if user_won else "üî¥"
                result_text = "ÂãùÂà©" if user_won else "ÊïóÂåó"
                user_rating_change_str = f"{user_rating_change:+.0f}" if user_rating_change != 0 else "¬±0"
                opponent_rating_change_str = f"{opponent_rating_change:+.0f}" if opponent_rating_change != 0 else "¬±0"
                
                # Êó•‰ªò„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
                match_date = match.get('match_date', '')
                if match_date:
                    match_date = match_date[:16]
                else:
                    match_date = 'Unknown'
                
                # „Ç∑„Éº„Ç∫„É≥ÊÉÖÂ†±
                season_name = match.get('season_name', 'Unknown')
                
                field_value = (
                    f"**ÁµêÊûúÔºö** {result_text}\n"
                    f"**„Ç∑„Éº„Ç∫„É≥Ôºö** {season_name}\n"
                    f"**„ÅÇ„Å™„Åü„ÅÆ„ÇØ„É©„ÇπÔºö** {user_selected_class}\n"
                    f"**Áõ∏Êâã„ÅÆ„ÇØ„É©„ÇπÔºö** {opponent_selected_class}\n"
                    f"**„É¨„Éº„ÉàÂ§âÂãïÔºö**\n"
                    f"‚îú „ÅÇ„Å™„ÅüÔºö {user_rating_change_str} (‚Üí {user_after_rating:.0f})\n"
                    f"‚îî Áõ∏ÊâãÔºö {opponent_rating_change_str} (‚Üí {opponent_after_rating:.0f})"
                )
                
                current_embed.add_field(
                    name=f"{result_emoji} {match_date}",
                    value=field_value,
                    inline=False
                )
            
            # ÊúÄÂàù„ÅÆEmbed„ÇíÈÄÅ‰ø°
            if embeds:
                message = await interaction.followup.send(embed=embeds[0], ephemeral=True)
                
                # Ë§áÊï∞„Éö„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„ÇíËøΩÂä†
                if len(embeds) > 1:
                    view = MatchHistoryPaginatorView(embeds)
                    await message.edit(view=view)
            
        except Exception as e:
            self.logger.error(f"Error showing opponent history: {e}")
            await interaction.followup.send("ÂØæÊà¶Â±•Ê≠¥„ÅÆÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)

class MatchHistoryPaginatorView(View):
    
    def __init__(self, embeds: List[discord.Embed]):
        super().__init__(timeout=600)
        self.embeds = embeds
        self.current = 0
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @discord.ui.button(label="‚¨ÖÔ∏è Ââç„Å∏", style=discord.ButtonStyle.primary)
    async def previous(self, button: Button, interaction: discord.Interaction):
        if self.current > 0:
            self.current -= 1
            await interaction.response.edit_message(embed=self.embeds[self.current], view=self)
        else:
            await interaction.response.defer()
    
    @discord.ui.button(label="‚û°Ô∏è Ê¨°„Å∏", style=discord.ButtonStyle.primary)
    async def next(self, button: Button, interaction: discord.Interaction):
        if self.current < len(self.embeds) - 1:
            self.current += 1
            await interaction.response.edit_message(embed=self.embeds[self.current], view=self)
        else:
            await interaction.response.defer()
    
    async def on_timeout(self):
        try:
            for item in self.children:
                item.disabled = True
        except Exception as e:
            self.logger.error(f"Error in on_timeout: {e}")

class DetailedMatchHistoryView(View):
    def __init__(self):
        super().__init__(timeout=None)
        
        # Ë©≥Á¥∞„Å™ÂÖ®ÂØæÊà¶Â±•Ê≠¥„Éú„Çø„É≥
        detailed_match_history_button = Button(label="Ë©≥Á¥∞„Å™ÂÖ®ÂØæÊà¶Â±•Ê≠¥", style=discord.ButtonStyle.secondary)
        async def detailed_match_history_callback(interaction):
            await self.show_detailed_match_history(interaction)
        detailed_match_history_button.callback = detailed_match_history_callback
        self.add_item(detailed_match_history_button)
    
    async def show_detailed_match_history(self, interaction: discord.Interaction):
        try:
            await interaction.response.defer(ephemeral=True)
            
            # „É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„ÇíÂèñÂæó
            user_model = UserModel()
            user_data = user_model.get_user_by_discord_id(str(interaction.user.id))
            
            if not user_data:
                await interaction.followup.send("„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                return
            
            # user_data„ÅåËæûÊõ∏„Åã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇíÂà§ÂÆö„Åó„Å¶ÈÅ©Âàá„Å´„Ç¢„ÇØ„Çª„Çπ
            def get_attr(data, attr_name, default=None):
                if isinstance(data, dict):
                    return data.get(attr_name, default)
                else:
                    return getattr(data, attr_name, default)
            
            user_id = get_attr(user_data, 'id')
            user_name = get_attr(user_data, 'user_name')
            
            # ÂÖ®Ë©¶ÂêàÂ±•Ê≠¥„ÇíÂèñÂæó
            match_model = MatchModel()
            matches = match_model.get_user_match_history(user_id, limit=None)  # ÂÖ®Â±•Ê≠¥
            
            # ÂÆå‰∫Ü„Åó„ÅüË©¶Âêà„ÅÆ„Åø„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            completed_matches = []
            for match in matches:
                if (match.get('winner_user_id') is not None and 
                    match.get('after_user1_rating') is not None and 
                    match.get('after_user2_rating') is not None):
                    completed_matches.append(match)
            
            if not completed_matches:
                await interaction.followup.send("ÂÆå‰∫Ü„Åó„ÅüË©¶ÂêàÂ±•Ê≠¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                return
            
            # Embed„Çí‰ΩúÊàê„Åó„Å¶Ë©≥Á¥∞„Å™Ë©¶ÂêàÂ±•Ê≠¥„ÇíË°®Á§∫
            embeds = []
            current_embed = None
            matches_per_embed = 8  # „ÇØ„É©„ÇπÊÉÖÂ†±„ÅåÂ§ö„ÅÑ„ÅÆ„Åß1„Éö„Éº„Ç∏„ÅÇ„Åü„Çä„ÅÆË©¶ÂêàÊï∞„ÇíÊ∏õ„Çâ„Åô
            
            for i, match in enumerate(completed_matches):
                # 8Ë©¶Âêà„Åî„Å®„Å´Êñ∞„Åó„ÅÑEmbed„Çí‰ΩúÊàê
                if i % matches_per_embed == 0:
                    page_num = i // matches_per_embed + 1
                    total_pages = (len(completed_matches) + matches_per_embed - 1) // matches_per_embed
                    current_embed = discord.Embed(
                        title=f"{user_name} „ÅÆÂÖ®ÂØæÊà¶Â±•Ê≠¥ (Page {page_num}/{total_pages})",
                        description=f"Á∑èË©¶ÂêàÊï∞: {len(completed_matches)}Ë©¶Âêà",
                        color=discord.Color.green()
                    )
                    embeds.append(current_embed)
                
                # ÂØæÊà¶Áõ∏Êâã„Å®Ëá™ÂàÜ„ÅÆÊÉÖÂ†±„ÇíÂèñÂæó
                if match['user1_id'] == user_id:
                    # Ëá™ÂàÜ„Ååuser1
                    opponent_data = user_model.get_user_by_id(match['user2_id'])
                    user_rating_change = match.get('user1_rating_change', 0)
                    after_rating = match.get('after_user1_rating')
                    user_won = match['winner_user_id'] == user_id
                    
                    # „ÇØ„É©„ÇπÊÉÖÂ†±
                    my_class_a = match.get('user1_class_a', 'Unknown')
                    my_class_b = match.get('user1_class_b', 'Unknown')
                    my_selected_class = match.get('user1_selected_class', 'Unknown')
                    opp_class_a = match.get('user2_class_a', 'Unknown')
                    opp_class_b = match.get('user2_class_b', 'Unknown')
                    opp_selected_class = match.get('user2_selected_class', 'Unknown')
                else:
                    # Ëá™ÂàÜ„Ååuser2
                    opponent_data = user_model.get_user_by_id(match['user1_id'])
                    user_rating_change = match.get('user2_rating_change', 0)
                    after_rating = match.get('after_user2_rating')
                    user_won = match['winner_user_id'] == user_id
                    
                    # „ÇØ„É©„ÇπÊÉÖÂ†±
                    my_class_a = match.get('user2_class_a', 'Unknown')
                    my_class_b = match.get('user2_class_b', 'Unknown')
                    my_selected_class = match.get('user2_selected_class', 'Unknown')
                    opp_class_a = match.get('user1_class_a', 'Unknown')
                    opp_class_b = match.get('user1_class_b', 'Unknown')
                    opp_selected_class = match.get('user1_selected_class', 'Unknown')
                
                opponent_name = get_attr(opponent_data, 'user_name', 'Unknown') if opponent_data else 'Unknown'
                
                # NoneÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ„Å®„Éá„Éï„Ç©„É´„ÉàÂÄ§Ë®≠ÂÆö
                if user_rating_change is None:
                    user_rating_change = 0
                if after_rating is None:
                    after_rating = 0
                
                # Ë©¶ÂêàÁµêÊûú„ÅÆË°®Á§∫
                result_emoji = "üîµ" if user_won else "üî¥"
                result_text = "ÂãùÂà©" if user_won else "ÊïóÂåó"
                rating_change_str = f"{user_rating_change:+.0f}" if user_rating_change != 0 else "¬±0"
                
                # „ÇØ„É©„ÇπÊÉÖÂ†±„ÅÆÊï¥ÁêÜ
                my_classes = f"{my_class_a or 'Unknown'} / {my_class_b or 'Unknown'}"
                opp_classes = f"{opp_class_a or 'Unknown'} / {opp_class_b or 'Unknown'}"
                
                # ÈÅ∏Êäû„ÇØ„É©„Çπ„ÅÆË°®Á§∫ÔºàNone„ÇÑÁ©∫ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅØUnknownÔºâ
                my_selected = my_selected_class if my_selected_class else 'Unknown'
                opp_selected = opp_selected_class if opp_selected_class else 'Unknown'
                
                # Êó•‰ªò„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
                match_date = match.get('match_date', '')
                if match_date:
                    match_date = match_date[:16]
                else:
                    match_date = 'Unknown'
                
                # „Ç∑„Éº„Ç∫„É≥ÊÉÖÂ†±
                season_name = match.get('season_name', 'Unknown')
                
                field_value = (
                    f"**ÂØæÊà¶Áõ∏Êâã:** {opponent_name}\n"
                    f"**ÁµêÊûú:** {result_text}\n"
                    f"**„É¨„Éº„ÉàÂ§âÂãï:** {rating_change_str} (‚Üí {after_rating:.0f})\n"
                    f"**„Ç∑„Éº„Ç∫„É≥:** {season_name}\n"
                    f"**„ÅÇ„Å™„Åü„ÅÆÁôªÈå≤„ÇØ„É©„Çπ:** {my_classes}\n"
                    f"**„ÅÇ„Å™„Åü„ÅÆÈÅ∏Êäû„ÇØ„É©„Çπ:** {my_selected}\n"
                    f"**Áõ∏Êâã„ÅÆÁôªÈå≤„ÇØ„É©„Çπ:** {opp_classes}\n"
                    f"**Áõ∏Êâã„ÅÆÈÅ∏Êäû„ÇØ„É©„Çπ:** {opp_selected}"
                )
                
                current_embed.add_field(
                    name=f"{result_emoji} {match_date}",
                    value=field_value,
                    inline=False
                )
            
            # ÊúÄÂàù„ÅÆEmbed„ÇíÈÄÅ‰ø°
            if embeds:
                message = await interaction.followup.send(embed=embeds[0], ephemeral=True)
                
                # Ë§áÊï∞„Éö„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„ÇíËøΩÂä†
                if len(embeds) > 1:
                    view = DetailedMatchHistoryPaginatorView(embeds)
                    await message.edit(view=view)
            
        except Exception as e:
            logging.getLogger(self.__class__.__name__).error(f"Error displaying detailed match history: {e}")
            import traceback
            logging.getLogger(self.__class__.__name__).error(traceback.format_exc())
            await interaction.followup.send("Ë©≥Á¥∞ÂØæÊà¶Â±•Ê≠¥„ÅÆÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)

class DetailedSeasonSelectView(View):
    """Ë©≥Á¥∞Êà¶Á∏æÁî®„ÅÆ„Ç∑„Éº„Ç∫„É≥ÈÅ∏ÊäûView"""
    
    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(DetailedSeasonSelect())

# views/record_view.py „ÅÆ DetailedSeasonSelect „ÇØ„É©„Çπ„ÅÆ‰øÆÊ≠£Áâà

class DetailedSeasonSelect(Select):
    """Ë©≥Á¥∞Êà¶Á∏æÁî®„ÅÆ„Ç∑„Éº„Ç∫„É≥ÈÅ∏Êäû„Çª„É¨„ÇØ„Éà"""
    
    def __init__(self):
        self.logger = logging.getLogger(self.__class__.__name__)
        
        season_model = SeasonModel()
        current_season = season_model.get_current_season()
        past_seasons = season_model.get_past_seasons()
        
        options = [discord.SelectOption(label="ÂÖ®„Ç∑„Éº„Ç∫„É≥", value="all")]

        options.append(discord.SelectOption(
            label="Êó•‰ªò„ÅßÁµû„ÇäËæº„ÇÄ", 
            value="date_range",
        ))
        
        # ÁèæÂú®„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíËøΩÂä†Ôºà‰øÆÊ≠£Ôºâ
        if current_season:
            options.append(discord.SelectOption(
                label=f"{current_season.season_name} (ÁèæÂú®)", 
                value=f"season_{current_season.id}",
                emoji="üåü"
            ))
        
        # ÈÅéÂéª„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíËøΩÂä†
        if past_seasons:
            for season in past_seasons:
                options.append(discord.SelectOption(
                    label=season['season_name'], 
                    value=f"season_{season['id']}"
                ))
        
        super().__init__(
            placeholder="„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ...", 
            options=options if options else [discord.SelectOption(label="„Ç∑„Éº„Ç∫„É≥„Å™„Åó", value="none")]
        )

    async def callback(self, interaction: discord.Interaction):
        """Ë©≥Á¥∞„Ç∑„Éº„Ç∫„É≥ÈÅ∏Êäû„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ"""
        selection = self.values[0]
        
        if selection == "all":
            # ÂÖ®„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà
            await interaction.response.send_message(
                content="„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö",
                view=DetailedClassSelectView(season_id=None, date_range=None),
                ephemeral=True
            )
        elif selection == "date_range":
            # Êó•‰ªòÁØÑÂõ≤„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà
            modal = DateRangeInputModal()
            await interaction.response.send_modal(modal)
        elif selection.startswith("season_"):
            # ÁâπÂÆö„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà
            season_id = int(selection.split("_")[1])
            season_model = SeasonModel()
            season_data = season_model.get_season_by_id(season_id)
            season_name = season_data['season_name'] if season_data else "‰∏çÊòé"
            
            await interaction.response.send_message(
                content=f"„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö",
                view=DetailedClassSelectView(season_id=season_id, date_range=None),
                ephemeral=True
            )
        else:
            await interaction.response.send_message("ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô„ÄÇ", ephemeral=True)

class DateRangeInputModal(discord.ui.Modal):
    """Êó•‰ªòÁØÑÂõ≤ÂÖ•ÂäõÁî®„ÅÆ„É¢„Éº„ÉÄ„É´"""
    
    def __init__(self):
        super().__init__(title="Êó•‰ªòÁØÑÂõ≤„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # ÁèæÂú®„ÅÆÊó•‰ªò„ÇíÂèñÂæó„Åó„Å¶„Éí„É≥„Éà„Å®„Åó„Å¶‰ΩøÁî®
        from datetime import datetime, timedelta
        from config.settings import JST
        
        today = datetime.now(JST)
        today_str = today.strftime('%Y-%m-%d')
        week_ago_str = (today - timedelta(days=7)).strftime('%Y-%m-%d')
        
        self.start_date_input = discord.ui.InputText(
            label="ÈñãÂßãÊó•",
            placeholder=f"‰æã: {week_ago_str} (YYYY-MM-DDÂΩ¢Âºè)",
            required=True,
            max_length=10
        )
        self.add_item(self.start_date_input)
        
        self.end_date_input = discord.ui.InputText(
            label="ÁµÇ‰∫ÜÊó•", 
            placeholder=f"‰æã: {today_str} (YYYY-MM-DDÂΩ¢Âºè)",
            required=True,
            max_length=10
        )
        self.add_item(self.end_date_input)
    
    async def callback(self, interaction: discord.Interaction):
        """„É¢„Éº„ÉÄ„É´ÈÄÅ‰ø°„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ"""
        start_date_str = self.start_date_input.value.strip()
        end_date_str = self.end_date_input.value.strip()
        
        self.logger.info(f"Date range input: {start_date_str} to {end_date_str} by user {interaction.user.id}")
        
        # Êó•‰ªòÂΩ¢Âºè„ÅÆ„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
        try:
            from datetime import datetime
            
            # Êó•‰ªò„ÅÆ„Éë„Éº„Çπ
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d')
            
            # ÈñãÂßãÊó•„ÅåÁµÇ‰∫ÜÊó•„Çà„ÇäÂæå„Åß„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if start_date > end_date:
                await interaction.response.send_message(
                    "‚ùå **„Ç®„É©„Éº:** ÈñãÂßãÊó•„ÅØÁµÇ‰∫ÜÊó•„Çà„ÇäÂâç„ÅÆÊó•‰ªò„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
                    f"ÂÖ•Âäõ„Åï„Çå„ÅüÂÄ§: ÈñãÂßãÊó• `{start_date_str}`, ÁµÇ‰∫ÜÊó• `{end_date_str}`",
                    ephemeral=True
                )
                return
            
            # Êú™Êù•„ÅÆÊó•‰ªò„Åß„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            from config.settings import JST
            now = datetime.now(JST).replace(tzinfo=None)  # „Çø„Ç§„É†„Çæ„Éº„É≥ÊÉÖÂ†±„ÇíÂâäÈô§
            
            if end_date > now:
                await interaction.response.send_message(
                    "‚ùå **„Ç®„É©„Éº:** ÁµÇ‰∫ÜÊó•„ÅØ‰ªäÊó•‰ª•Ââç„ÅÆÊó•‰ªò„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
                    f"‰ªäÊó•„ÅÆÊó•‰ªò: `{now.strftime('%Y-%m-%d')}`",
                    ephemeral=True
                )
                return
            
            # Êó•Êï∞„ÇíË®àÁÆó
            days_diff = (end_date - start_date).days
            
            # ISOÂΩ¢Âºè„ÅÆÊñáÂ≠óÂàó„Å´Â§âÊèõÔºàÊôÇÂàªÊÉÖÂ†±„ÇíËøΩÂä†Ôºâ
            start_date_iso = f"{start_date_str} 00:00:00"
            end_date_iso = f"{end_date_str} 23:59:59"
            
            date_range = (start_date_iso, end_date_iso)
            range_description = f"{start_date_str} ÔΩû {end_date_str}"
            
            self.logger.info(f"Valid date range processed: {range_description} ({days_diff + 1}Êó•Èñì)")
            
            # „ÇØ„É©„ÇπÈÅ∏Êäû„ÇíË°®Á§∫
            await interaction.response.send_message(
                content=f"‚úÖ **Êó•‰ªòÁØÑÂõ≤Ë®≠ÂÆöÂÆå‰∫Ü**\n"
                        f"üìÖ ÂØæË±°ÊúüÈñì: **{range_description}** ({days_diff + 1}Êó•Èñì)\n"
                        f"üéØ Ê¨°„Å´Ë©≥Á¥∞Êà¶Á∏æ„ÅÆ„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:",
                view=DetailedClassSelectView(season_id=None, date_range=date_range),
                ephemeral=True
            )
            
        except ValueError as e:
            self.logger.warning(f"Invalid date format from user {interaction.user.id}: {start_date_str}, {end_date_str}")
            await interaction.response.send_message(
                "‚ùå **„Ç®„É©„Éº:** Êó•‰ªò„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ\n\n"
                "**Ê≠£„Åó„ÅÑÂΩ¢Âºè:** `YYYY-MM-DD`\n"
                "**‰æã:** `2024-01-01`\n"
                f"**ÂÖ•Âäõ„Åï„Çå„ÅüÂÄ§:** ÈñãÂßãÊó• `{start_date_str}`, ÁµÇ‰∫ÜÊó• `{end_date_str}`\n\n"
                "Âπ¥„ÅØ4Ê°Å„ÄÅÊúà„Å®Êó•„ÅØ2Ê°Å„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                ephemeral=True
            )
        except Exception as e:
            self.logger.error(f"Error in date range input from user {interaction.user.id}: {e}")
            await interaction.response.send_message(
                "‚ùå Êó•‰ªò„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ\n"
                "ÂÖ•ÂäõÂΩ¢Âºè„ÇíÁ¢∫Ë™ç„Åó„Å¶ÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ",
                ephemeral=True
            )

class DetailedClassSelectView(View):
    """Ë©≥Á¥∞Êà¶Á∏æÁî®„ÅÆ„ÇØ„É©„ÇπÈÅ∏ÊäûView"""
    
    def __init__(self, season_id: Optional[int] = None, date_range: Optional[tuple] = None):
        super().__init__(timeout=None)
        self.add_item(DetailedClassSelect(season_id, date_range))

class DetailedClassSelect(Select):
    """Ë©≥Á¥∞Êà¶Á∏æÁî®„ÅÆ„ÇØ„É©„ÇπÈÅ∏Êäû„Çª„É¨„ÇØ„ÉàÔºà1„Å§„Åæ„Åü„ÅØ2„Å§ÈÅ∏ÊäûÂèØËÉΩÔºâ"""
    
    def __init__(self, season_id: Optional[int] = None, date_range: Optional[tuple] = None):
        self.season_id = season_id
        self.date_range = date_range
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„Çâ„ÇØ„É©„ÇπÂêç„ÇíÂèñÂæó
        user_model = UserModel()
        valid_classes = user_model.get_valid_classes()
        
        # ÂÖ®„ÇØ„É©„Çπ„Çí‰∏ÄÁï™‰∏ä„Å´ÁΩÆ„Åè
        options = [discord.SelectOption(label="ÂÖ®„ÇØ„É©„Çπ", value="all_classes")]
        options.extend([discord.SelectOption(label=cls, value=cls) for cls in valid_classes])
        
        super().__init__(
            placeholder="„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà1„Å§„Åæ„Åü„ÅØ2„Å§Ôºâ...", 
            min_values=1, 
            max_values=min(2, len(options)),  # ÊúÄÂ§ß2„Å§„Åæ„ÅßÈÅ∏ÊäûÂèØËÉΩ
            options=options
        )
    
    async def callback(self, interaction: discord.Interaction):
        """Ë©≥Á¥∞„ÇØ„É©„ÇπÈÅ∏Êäû„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØÔºà‰øÆÊ≠£ÁâàÔºâ"""
        selected_classes = self.values
        user_id = interaction.user.id
        
        # „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Çí‰∏ÄÂ∫¶Ë°å„ÅÜ
        await interaction.response.defer(ephemeral=True)
        
        try:
            # RecordViewModel„ÇíÈÅÖÂª∂„Ç§„É≥„Éù„Éº„Éà
            from viewmodels.record_vm import RecordViewModel
            record_vm = RecordViewModel()
            
            if "all_classes" in selected_classes:
                # ÂÖ®„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥Âêà
                if self.season_id:
                    await record_vm.show_season_stats(interaction, user_id, self.season_id)
                elif self.date_range:
                    await record_vm.show_date_range_stats(interaction, user_id, self.date_range)
                else:
                    await record_vm.show_all_time_stats(interaction, user_id)
            else:
                # ÁâπÂÆö„ÅÆ„ÇØ„É©„ÇπÔºà1„Å§„Åæ„Åü„ÅØ2„Å§Ôºâ„ÇíÈÅ∏Êäû„Åó„ÅüÂ†¥ÂêàÔºà‰øÆÊ≠£ÔºöÂøÖ„ÅöË©≥Á¥∞Êà¶Á∏æ„ÇíË°®Á§∫Ôºâ
                await record_vm.show_detailed_class_stats(interaction, user_id, selected_classes, self.season_id, self.date_range)
        
        except Exception as e:
            self.logger.error(f"Error in detailed class selection callback: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            await interaction.followup.send("„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)
        
        # „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂâäÈô§„Åô„Çã
        try:
            await interaction.delete_original_response()
        except discord.errors.NotFound:
            pass

class RecordClassSelectView(View):
    """Êà¶Á∏æÁî®„ÇØ„É©„ÇπÈÅ∏ÊäûViewÔºàÂçò‰∏Ä„ÇØ„É©„Çπ„Åæ„Åü„ÅØÂÖ®„ÇØ„É©„Çπ„ÅÆ„ÅøÈÅ∏ÊäûÂèØËÉΩÔºâ"""
    
    def __init__(self, season_id: Optional[int] = None):
        super().__init__(timeout=None)
        self.add_item(RecordClassSelect(season_id))

class RecordClassSelect(Select):
    """Êà¶Á∏æÁî®„ÇØ„É©„ÇπÈÅ∏Êäû„Çª„É¨„ÇØ„ÉàÔºàÂçò‰∏Ä„ÇØ„É©„Çπ„Åæ„Åü„ÅØÂÖ®„ÇØ„É©„Çπ„ÅÆ„ÅøÈÅ∏ÊäûÂèØËÉΩÔºâ"""
    
    def __init__(self, season_id: Optional[int] = None):
        self.season_id = season_id
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„Çâ„ÇØ„É©„ÇπÂêç„ÇíÂèñÂæó
        user_model = UserModel()
        valid_classes = user_model.get_valid_classes()
        
        # ÂÖ®„ÇØ„É©„Çπ„Çí‰∏ÄÁï™‰∏ä„Å´ÁΩÆ„Åè
        options = [discord.SelectOption(label="ÂÖ®„ÇØ„É©„Çπ", value="all_classes")]
        options.extend([discord.SelectOption(label=cls, value=cls) for cls in valid_classes])
        
        super().__init__(
            placeholder="„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ...", 
            min_values=1, 
            max_values=1, 
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        """„ÇØ„É©„ÇπÈÅ∏Êäû„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ"""
        selected_class = self.values[0]
        user_id = interaction.user.id
        
        # „Ç§„É≥„Çø„É©„ÇØ„Ç∑„Éß„É≥„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Çí‰∏ÄÂ∫¶Ë°å„ÅÜ
        await interaction.response.defer(ephemeral=True)

        try:
            # RecordViewModel„ÇíÈÅÖÂª∂„Ç§„É≥„Éù„Éº„Éà
            from viewmodels.record_vm import RecordViewModel
            record_vm = RecordViewModel()

            if selected_class == "all_classes":
                if self.season_id:
                    await record_vm.show_season_stats(interaction, user_id, self.season_id)
                else:
                    await record_vm.show_all_time_stats(interaction, user_id)
            else:
                await record_vm.show_class_stats(interaction, user_id, selected_class, self.season_id)

        except Exception as e:
            self.logger.error(f"Error in class selection callback: {e}")
            await interaction.followup.send("„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)

        try:
            await interaction.delete_original_response()
        except discord.errors.NotFound:
            pass

class PastSeasonRecordView(View):
    """ÈÅéÂéª„Ç∑„Éº„Ç∫„É≥„ÅÆÊà¶Á∏æË°®Á§∫View"""

    def __init__(self):
        super().__init__(timeout=None)
        button = Button(label="ÈÅéÂéª„ÅÆ„Ç∑„Éº„Ç∫„É≥", style=discord.ButtonStyle.secondary)

        async def button_callback(interaction):
            await self.show_season_select(interaction)

        button.callback = button_callback
        self.add_item(button)

    async def show_season_select(self, interaction: discord.Interaction):
        """„Ç∑„Éº„Ç∫„É≥ÈÅ∏Êäû„ÇíË°®Á§∫"""
        season_model = SeasonModel()
        seasons = season_model.get_past_seasons()

        options = [
            discord.SelectOption(label="ÂÖ®„Ç∑„Éº„Ç∫„É≥", value="all")
        ]

        used_values = set()
        for season in seasons:
            value = str(season['id'])
            if value in used_values:
                value = f"{season['id']}_{season['season_name']}"
            options.append(discord.SelectOption(label=season['season_name'], value=value))
            used_values.add(value)

        select = Select(placeholder="„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ...", options=options)

        async def select_callback(select_interaction):
            if not select_interaction.response.is_done():
                await select_interaction.response.defer(ephemeral=True)

            selected_season_id = select_interaction.data['values'][0]

            if selected_season_id == "all":
                await select_interaction.followup.send(
                    content="„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:", 
                    view=RecordClassSelectView(season_id=None),  # ‰øÆÊ≠£: RecordClassSelectView„Çí‰ΩøÁî®
                    ephemeral=True
                )
            else:
                selected_season_id = int(selected_season_id.split('_')[0])
                user_model = UserModel()
                user = user_model.get_user_by_discord_id(str(select_interaction.user.id))
                
                if not user:
                    await select_interaction.followup.send("„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                    return

                season_model = SeasonModel()
                user_record = season_model.get_user_season_record(user['id'], selected_season_id)

                if user_record is None:
                    message = await select_interaction.followup.send("Êú™ÂèÇÂä†„Åß„Åô„ÄÇ", ephemeral=True)
                    await asyncio.sleep(10)
                    try:
                        await message.delete()
                    except discord.errors.NotFound:
                        pass
                    return

                await select_interaction.followup.send(
                    content="„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:", 
                    view=RecordClassSelectView(season_id=selected_season_id),  # ‰øÆÊ≠£: RecordClassSelectView„Çí‰ΩøÁî®
                    ephemeral=True
                )

        select.callback = select_callback
        view = View()
        view.add_item(select)

        await interaction.response.send_message("„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:", view=view, ephemeral=True)

        await asyncio.sleep(15)
        try:
            await interaction.delete_original_response()
        except discord.errors.NotFound:
            pass

class Last50RecordView(View):
    """Áõ¥Ëøë50Êà¶„ÅÆÊà¶Á∏æË°®Á§∫View"""

    def __init__(self):
        super().__init__(timeout=None)
        self.add_item(Last50RecordButton())

class Last50RecordButton(Button):
    """Áõ¥Ëøë50Êà¶Êà¶Á∏æË°®Á§∫„Éú„Çø„É≥"""

    def __init__(self):
        super().__init__(label="Áõ¥Ëøë50Êà¶„ÅÆÊà¶Á∏æ", style=discord.ButtonStyle.primary)
        self.logger = logging.getLogger(self.__class__.__name__)

    async def callback(self, interaction: discord.Interaction):
        """Áõ¥Ëøë50Êà¶Êà¶Á∏æË°®Á§∫„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ"""
        try:
            await interaction.response.defer(ephemeral=True)

            # MatchModel„Çí‰ΩøÁî®„Åó„Å¶Áõ¥Ëøë50Êà¶„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó
            from models.match import MatchModel
            from models.user import UserModel

            user_model = UserModel()
            match_model = MatchModel()

            # „É¶„Éº„Ç∂„ÉºÊÉÖÂ†±„ÇíÂèñÂæó
            user_data = user_model.get_user_by_discord_id(str(interaction.user.id))
            if not user_data:
                await interaction.followup.send("„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                return

            # user_data„ÅåËæûÊõ∏„Åã„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åã„ÇíÂà§ÂÆö„Åó„Å¶ÈÅ©Âàá„Å´„Ç¢„ÇØ„Çª„Çπ
            def get_attr(data, attr_name, default=None):
                if isinstance(data, dict):
                    return data.get(attr_name, default)
                else:
                    return getattr(data, attr_name, default)

            user_id = get_attr(user_data, 'id')
            user_name = get_attr(user_data, 'user_name')
            
            # Ë©¶ÂêàÂ±•Ê≠¥„ÇíÂèñÂæóÔºà50Êà¶„ÅÆ„ÅøÔºâ
            matches = match_model.get_user_match_history(user_id, 50)
            
            # ÂÆå‰∫Ü„Åó„ÅüË©¶Âêà„ÅÆ„Åø„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
            completed_matches = []
            for match in matches:
                if (match.get('winner_user_id') is not None and
                    match.get('after_user1_rating') is not None and
                    match.get('after_user2_rating') is not None):
                    completed_matches.append(match)
            
            if not completed_matches:
                await interaction.followup.send("ÂÆå‰∫Ü„Åó„ÅüË©¶ÂêàÂ±•Ê≠¥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
                return
            
            # Embed„Çí‰ΩúÊàê„Åó„Å¶Ë©¶ÂêàÂ±•Ê≠¥„ÇíË°®Á§∫
            embeds = []
            current_embed = None
            matches_per_embed = 10
            
            for i, match in enumerate(completed_matches):
                # 10Ë©¶Âêà„Åî„Å®„Å´Êñ∞„Åó„ÅÑEmbed„Çí‰ΩúÊàê
                if i % matches_per_embed == 0:
                    current_embed = discord.Embed(
                        title=f"{user_name} „ÅÆÁõ¥Ëøë50Êà¶ (Page {i//matches_per_embed + 1})",
                        color=discord.Color.blue()
                    )
                    embeds.append(current_embed)
                
                # ÂØæÊà¶Áõ∏ÊâãÂêç„ÇíÂèñÂæó
                if match['user1_id'] == user_id:
                    opponent_data = user_model.get_user_by_id(match['user2_id'])
                    user_rating_change = match.get('user1_rating_change', 0)
                    after_rating = match.get('after_user1_rating')
                    before_rating = match.get('before_user1_rating')
                    user_won = match['winner_user_id'] == user_id
                else:
                    opponent_data = user_model.get_user_by_id(match['user1_id'])
                    user_rating_change = match.get('user2_rating_change', 0)
                    after_rating = match.get('after_user2_rating')
                    before_rating = match.get('before_user2_rating')
                    user_won = match['winner_user_id'] == user_id
                
                if opponent_data:
                    opponent_name = get_attr(opponent_data, 'user_name', 'Unknown')
                    opponent_discord_id = get_attr(opponent_data, 'discord_id', None)
                    
                    # Discord Username „ÇíÂèñÂæó
                    opponent_username = None
                    if opponent_discord_id:
                        try:
                            discord_member = interaction.guild.get_member(int(opponent_discord_id))
                            if discord_member:
                                opponent_username = discord_member.name
                        except (ValueError, AttributeError):
                            pass
                    
                    if opponent_username:
                        opponent_display = f"{opponent_name} (@{opponent_username})"
                    else:
                        opponent_display = opponent_name
                else:
                    opponent_display = 'Unknown'
                
                # NoneÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ„Å®„Éá„Éï„Ç©„É´„ÉàÂÄ§Ë®≠ÂÆö
                if user_rating_change is None:
                    user_rating_change = 0
                if after_rating is None:
                    after_rating = 0
                if before_rating is None:
                    before_rating = 0
                
                # Ë©¶ÂêàÁµêÊûú„ÅÆË°®Á§∫
                result_emoji = "üîµ" if user_won else "üî¥"
                result_text = "ÂãùÂà©" if user_won else "ÊïóÂåó"
                rating_change_str = f"{user_rating_change:+.0f}" if user_rating_change != 0 else "¬±0"
                
                # ‰ΩøÁî®„ÇØ„É©„ÇπÊÉÖÂ†±„ÇíÂèñÂæóÔºàÊñ∞„Åó„ÅÑ„Éá„Éº„Çø„Éô„Éº„ÇπÊßãÈÄ†ÂØæÂøúÔºâ
                if match['user1_id'] == user_id:
                    user_class = match.get('user1_selected_class', 'Unknown')
                else:
                    user_class = match.get('user2_selected_class', 'Unknown')
                
                # None„ÇÑÁ©∫ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅØUnknown„Å´Ë®≠ÂÆö
                if not user_class:
                    user_class = 'Unknown'
                
                field_value = (
                    f"vs {opponent_display}\n"
                    f"ÁµêÊûú: {result_text}\n"
                    f"‰ΩøÁî®„ÇØ„É©„Çπ: {user_class}\n"
                    f"„É¨„Éº„ÉàÂ§âÂãï: {rating_change_str}\n"
                    f"Ë©¶ÂêàÂæå„É¨„Éº„Éà: {after_rating:.0f}"
                )
                
                # Êó•‰ªò„ÅÆ„Éï„Ç©„Éº„Éû„ÉÉ„Éà
                match_date = match.get('match_date', '')
                if match_date:
                    match_date = match_date[:16]
                else:
                    match_date = 'Unknown'
                
                current_embed.add_field(
                    name=f"{result_emoji} {match_date}",
                    value=field_value,
                    inline=False
                )
            
            # ÊúÄÂàù„ÅÆEmbed„ÇíÈÄÅ‰ø°
            if embeds:
                message = await interaction.followup.send(embed=embeds[0], ephemeral=True)
                
                # Ë§áÊï∞„Éö„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥„ÇíËøΩÂä†
                if len(embeds) > 1:
                    view = MatchHistoryPaginatorView(embeds)
                    await message.edit(view=view)
            
        except Exception as e:
            self.logger.error(f"Error displaying last 50 matches: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            await interaction.followup.send("Êà¶Á∏æ„ÅÆÂèñÂæó‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)

class DetailedMatchHistoryPaginatorView(View):
    """Ë©≥Á¥∞ÂØæÊà¶Â±•Ê≠¥„ÅÆ„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥View"""
    
    def __init__(self, embeds: List[discord.Embed]):
        super().__init__(timeout=600)
        self.embeds = embeds
        self.current = 0
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @discord.ui.button(label="‚¨ÖÔ∏è Ââç„Å∏", style=discord.ButtonStyle.primary)
    async def previous(self, button: Button, interaction: discord.Interaction):
        """Ââç„ÅÆ„Éö„Éº„Ç∏„Å∏"""
        if self.current > 0:
            self.current -= 1
            await interaction.response.edit_message(embed=self.embeds[self.current], view=self)
        else:
            await interaction.response.defer()
    
    @discord.ui.button(label="‚û°Ô∏è Ê¨°„Å∏", style=discord.ButtonStyle.primary)
    async def next(self, button: Button, interaction: discord.Interaction):
        """Ê¨°„ÅÆ„Éö„Éº„Ç∏„Å∏"""
        if self.current < len(self.embeds) - 1:
            self.current += 1
            await interaction.response.edit_message(embed=self.embeds[self.current], view=self)
        else:
            await interaction.response.defer()
    
    @discord.ui.button(label="üî¢ „Éö„Éº„Ç∏ÊÉÖÂ†±", style=discord.ButtonStyle.secondary)
    async def page_info(self, button: Button, interaction: discord.Interaction):
        """ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏ÊÉÖÂ†±„ÇíË°®Á§∫"""
        await interaction.response.send_message(
            f"ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏: {self.current + 1} / {len(self.embeds)}", 
            ephemeral=True
        )
    
    async def on_timeout(self):
        """„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÊôÇ„ÅÆÂá¶ÁêÜ"""
        try:
            # „Éú„Çø„É≥„ÇíÁÑ°ÂäπÂåñ
            for item in self.children:
                item.disabled = True
        except Exception as e:
            self.logger.error(f"Error in on_timeout: {e}")

class OpponentClassAnalysisView(View):
    
    def __init__(self):
        super().__init__(timeout=None)
        
        analysis_wins_button = Button(
            label="Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûêÔºàÂãùÂà©Êï∞È†ÜÔºâ", 
            style=discord.ButtonStyle.success,
            emoji="üèÜ"
        )
        async def analysis_wins_callback(interaction):
            await self.show_analysis_season_select(interaction, "wins")
        analysis_wins_button.callback = analysis_wins_callback
        self.add_item(analysis_wins_button)
        
        analysis_rate_button = Button(
            label="Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûêÔºàÂãùÁéáÈ†ÜÔºâ", 
            style=discord.ButtonStyle.primary,
            emoji="üìä"
        )
        async def analysis_rate_callback(interaction):
            await self.show_analysis_season_select(interaction, "rate")
        analysis_rate_button.callback = analysis_rate_callback
        self.add_item(analysis_rate_button)
    
    async def show_analysis_season_select(self, interaction: discord.Interaction, sort_type: str):
        user_model = UserModel()
        user = user_model.get_user_by_discord_id(str(interaction.user.id))
        
        if not user:
            await interaction.response.send_message("„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
            return
        
        await interaction.response.send_message(
            content="Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûê„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:", 
            view=OpponentAnalysisSeasonSelectView(sort_type), 
            ephemeral=True
        )

class OpponentAnalysisSeasonSelectView(View):
    
    def __init__(self, sort_type: str):
        super().__init__(timeout=None)
        self.sort_type = sort_type
        self.add_item(OpponentAnalysisSeasonSelect(sort_type))

class OpponentAnalysisSeasonSelect(Select):
    
    def __init__(self, sort_type: str):
        self.sort_type = sort_type
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # ÁèæÂú®„ÅÆ„Ç∑„Éº„Ç∫„É≥„Å®ÈÅéÂéª„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíÂèñÂæó
        season_model = SeasonModel()
        current_season = season_model.get_current_season()
        past_seasons = season_model.get_past_seasons()
        
        # ÂÖ®„Ç∑„Éº„Ç∫„É≥„Ç™„Éó„Ç∑„Éß„É≥„Çí‰∏ÄÁï™‰∏ä„Å´
        options = [discord.SelectOption(label="ÂÖ®„Ç∑„Éº„Ç∫„É≥", value="all")]
        
        # ÁèæÂú®„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíËøΩÂä†
        if current_season:
            options.append(discord.SelectOption(
                label=current_season.season_name, 
                value=f"current_{current_season.id}"
            ))
        
        # ÈÅéÂéª„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíËøΩÂä†
        for season in past_seasons:
            options.append(discord.SelectOption(
                label=season['season_name'], 
                value=f"past_{season['id']}"
            ))
        
        # Êó•‰ªò„ÅßÁµû„ÇäËæº„ÇÄ„Ç™„Éó„Ç∑„Éß„É≥„Çí‰∏ÄÁï™‰∏ã„Å´ËøΩÂä†
        options.append(discord.SelectOption(
            label="Êó•‰ªò„ÅßÁµû„ÇäËæº„ÇÄ", 
            value="date_range",
            emoji="üìÖ"
        ))
        
        super().__init__(
            placeholder="„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ...", 
            options=options if options else [discord.SelectOption(label="„Ç∑„Éº„Ç∫„É≥„Å™„Åó", value="none")]
        )
    
    async def callback(self, interaction: discord.Interaction):
        """„Ç∑„Éº„Ç∫„É≥ÈÅ∏Êäû„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ"""
        selected_value = self.values[0]
        
        if selected_value == "none":
            await interaction.response.send_message("Âà©Áî®ÂèØËÉΩ„Å™„Ç∑„Éº„Ç∫„É≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
            return
        
        if selected_value == "date_range":
            # Êó•‰ªòÁØÑÂõ≤ÂÖ•Âäõ„É¢„Éº„ÉÄ„É´„ÇíË°®Á§∫
            modal = OpponentAnalysisDateRangeModal(self.sort_type)
            await interaction.response.send_modal(modal)
            return
        
        await interaction.response.defer(ephemeral=True)
        
        # ÈÅ∏Êäû„Åï„Çå„ÅüÂÄ§„ÇíËß£Êûê
        if selected_value == "all":
            season_id = None
            season_name = None
        elif selected_value.startswith("current_"):
            season_id = int(selected_value.split("_")[1])
            season_model = SeasonModel()
            season_data = season_model.get_season_by_id(season_id)
            season_name = season_data['season_name'] if season_data else None
        elif selected_value.startswith("past_"):
            season_id = int(selected_value.split("_")[1])
            season_model = SeasonModel()
            season_data = season_model.get_season_by_id(season_id)
            season_name = season_data['season_name'] if season_data else None
        else:
            await interaction.followup.send("ÁÑ°Âäπ„Å™ÈÅ∏Êäû„Åß„Åô„ÄÇ", ephemeral=True)
            return
        
        # „ÇØ„É©„ÇπÈÅ∏Êäû„ÇíË°®Á§∫
        await interaction.followup.send(
            content="Ëá™ÂàÜ„ÅÆ‰ΩøÁî®„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ1„Å§„ÅÆ„ÅøÈÅ∏„Çì„Å†Â†¥Âêà„ÄÅ„Åù„ÅÆ„ÇØ„É©„Çπ„ÇíÂê´„ÇÄ„Åô„Åπ„Å¶„ÅÆÂØæÊà¶„ÇíÈõÜË®à„Åó„Åæ„Åô", 
            view=OpponentAnalysisClassSelectView(self.sort_type, season_id, season_name),
            ephemeral=True
        )

class OpponentAnalysisDateRangeModal(discord.ui.Modal):
    
    def __init__(self, sort_type: str):
        super().__init__(title="Êó•‰ªòÁØÑÂõ≤„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
        self.sort_type = sort_type
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # ÁèæÂú®„ÅÆÊó•‰ªò„ÇíÂèñÂæó„Åó„Å¶„Éí„É≥„Éà„Å®„Åó„Å¶‰ΩøÁî®
        from datetime import datetime, timedelta
        from config.settings import JST
        
        today = datetime.now(JST)
        today_str = today.strftime('%Y-%m-%d')
        week_ago_str = (today - timedelta(days=7)).strftime('%Y-%m-%d')
        
        self.start_date_input = discord.ui.InputText(
            label="ÈñãÂßãÊó•",
            placeholder=f"‰æã: {week_ago_str} (YYYY-MM-DDÂΩ¢Âºè)",
            required=True,
            max_length=10
        )
        self.add_item(self.start_date_input)
        
        self.end_date_input = discord.ui.InputText(
            label="ÁµÇ‰∫ÜÊó•", 
            placeholder=f"‰æã: {today_str} (YYYY-MM-DDÂΩ¢Âºè)",
            required=True,
            max_length=10
        )
        self.add_item(self.end_date_input)
    
    async def callback(self, interaction: discord.Interaction):
        """„É¢„Éº„ÉÄ„É´ÈÄÅ‰ø°„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ"""
        start_date_str = self.start_date_input.value.strip()
        end_date_str = self.end_date_input.value.strip()
        
        # Êó•‰ªòÂΩ¢Âºè„ÅÆ„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
        try:
            from datetime import datetime
            
            # Êó•‰ªò„ÅÆ„Éë„Éº„Çπ
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d')
            
            # ÈñãÂßãÊó•„ÅåÁµÇ‰∫ÜÊó•„Çà„ÇäÂæå„Åß„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if start_date > end_date:
                await interaction.response.send_message(
                    "‚ùå **„Ç®„É©„Éº:** ÈñãÂßãÊó•„ÅØÁµÇ‰∫ÜÊó•„Çà„ÇäÂâç„ÅÆÊó•‰ªò„ÇíÊåáÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                    ephemeral=True
                )
                return
            
            # ISOÂΩ¢Âºè„ÅÆÊñáÂ≠óÂàó„Å´Â§âÊèõ
            start_date_iso = f"{start_date_str} 00:00:00"
            end_date_iso = f"{end_date_str} 23:59:59"
            date_range = (start_date_iso, end_date_iso)
            
            # „ÇØ„É©„ÇπÈÅ∏Êäû„ÇíË°®Á§∫
            await interaction.response.send_message(
                content=f"üìÖ ÂØæË±°ÊúüÈñì: **{start_date_str} ÔΩû {end_date_str}**\n"
                        f"Ëá™ÂàÜ„ÅÆ‰ΩøÁî®„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ1„Å§„ÅÆ„ÅøÈÅ∏„Çì„Å†Â†¥Âêà„ÄÅ„Åù„ÅÆ„ÇØ„É©„Çπ„ÇíÂê´„ÇÄ„Åô„Åπ„Å¶„ÅÆÂØæÊà¶„ÇíÈõÜË®à„Åó„Åæ„Åô",
                view=OpponentAnalysisClassSelectView(self.sort_type, None, None, date_range),
                ephemeral=True
            )
            
        except ValueError:
            await interaction.response.send_message(
                "‚ùå **„Ç®„É©„Éº:** Êó•‰ªò„ÅÆÂΩ¢Âºè„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇYYYY-MM-DDÂΩ¢Âºè„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
                ephemeral=True
            )

class OpponentAnalysisClassSelectView(View):
    
    def __init__(self, sort_type: str, season_id: Optional[int] = None, 
                 season_name: Optional[str] = None, date_range: Optional[tuple] = None):
        super().__init__(timeout=None)
        self.add_item(OpponentAnalysisClassSelect(sort_type, season_id, season_name, date_range))

class OpponentAnalysisClassSelect(Select):
    
    def __init__(self, sort_type: str, season_id: Optional[int] = None, 
                 season_name: Optional[str] = None, date_range: Optional[tuple] = None):
        self.sort_type = sort_type
        self.season_id = season_id
        self.season_name = season_name
        self.date_range = date_range
        self.logger = logging.getLogger(self.__class__.__name__)
        
        # „Éá„Éº„Çø„Éô„Éº„Çπ„Åã„Çâ„ÇØ„É©„ÇπÂêç„ÇíÂèñÂæó
        user_model = UserModel()
        valid_classes = user_model.get_valid_classes()
        
        options = [discord.SelectOption(label=cls, value=cls) for cls in valid_classes]
        
        super().__init__(
            placeholder="„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºà1„Å§„Åæ„Åü„ÅØ2„Å§Ôºâ...", 
            min_values=1, 
            max_values=min(2, len(options)),
            options=options
        )
    
    async def callback(self, interaction: discord.Interaction):
        """„ÇØ„É©„ÇπÈÅ∏Êäû„ÅÆ„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ"""
        selected_classes = self.values
        
        await interaction.response.defer(ephemeral=True)
        
        try:
            # ÂàÜÊûê„Éá„Éº„Çø„ÇíÂèñÂæó
            analysis_data = await self.get_opponent_class_analysis_data(
                selected_classes, self.season_id, self.season_name, self.date_range
            )
            
            if not analysis_data:
                await interaction.followup.send(
                    "ÊåáÂÆö„Åó„ÅüÊù°‰ª∂„Åß„ÅÆÂØæÊà¶„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ", 
                    ephemeral=True
                )
                return
            
            # „ÇΩ„Éº„Éà‰øÆÊ≠£
            if self.sort_type == "wins":
                # ÂãùÂà©Êï∞È†ÜÔºàËá™ÂàÜ„ÅÆÂãùÂà©Êï∞„ÅßÂ§ö„ÅÑÈ†ÜÔºâ
                sorted_data = sorted(analysis_data, key=lambda x: (x['my_wins'], x['win_rate']), reverse=True)
            else:  # rate
                # ÂãùÁéáÈ†ÜÔºàÈ´ò„ÅÑÈ†Ü„ÄÅÂêåÁéáÊôÇ„ÅØÂãùÂà©Êï∞„ÅßÔºâ
                sorted_data = sorted(analysis_data, key=lambda x: (x['win_rate'], x['my_wins']), reverse=True)
            
            # Êù°‰ª∂Ë™¨Êòé„Çí‰ΩúÊàê
            if len(selected_classes) == 1:
                class_desc = f"{selected_classes[0]}Âçò‰Ωì"
            else:
                class_desc = f"{selected_classes[0]} + {selected_classes[1]}"
            
            if self.season_name:
                period_desc = f"„Ç∑„Éº„Ç∫„É≥ {self.season_name}"
            elif self.date_range:
                start_date = self.date_range[0][:10]
                end_date = self.date_range[1][:10]
                period_desc = f"{start_date} ÔΩû {end_date}"
            else:
                period_desc = "ÂÖ®„Ç∑„Éº„Ç∫„É≥"
            
            sort_desc = "ÂãùÂà©Êï∞È†Ü" if self.sort_type == "wins" else "ÂãùÁéáÈ†Ü"
            
            # „Éö„Éº„Ç∏ÂàÜÂâ≤„Åó„Å¶Ë°®Á§∫
            embeds = self.create_analysis_embeds(
                sorted_data, class_desc, period_desc, sort_desc
            )
            
            if embeds:
                message = await interaction.followup.send(embed=embeds[0], ephemeral=True)
                
                if len(embeds) > 1:
                    from views.record_view import OpponentAnalysisPaginatorView
                    view = OpponentAnalysisPaginatorView(embeds)
                    await message.edit(view=view)
            
        except Exception as e:
            self.logger.error(f"Error in opponent class analysis: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            await interaction.followup.send("„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ", ephemeral=True)
    
    async def get_opponent_class_analysis_data(self, selected_classes: List[str], 
                                             season_id: Optional[int], season_name: Optional[str],
                                             date_range: Optional[tuple]) -> List[Dict]:
        def _get_analysis_data(session):
            from config.database import MatchHistory
            from sqlalchemy import or_, and_
            from itertools import combinations
            
            # „Éô„Éº„Çπ„ÇØ„Ç®„É™ÔºöÂÆå‰∫Ü„Åó„ÅüË©¶Âêà„ÅÆ„Åø
            query = session.query(MatchHistory).filter(
                MatchHistory.winner_user_id.isnot(None)
            )
            
            # ÊúüÈñì„Éï„Ç£„É´„Çø„Éº
            if season_name:
                query = query.filter(MatchHistory.season_name == season_name)
            elif date_range:
                start_date, end_date = date_range
                query = query.filter(
                    and_(
                        MatchHistory.match_date >= start_date,
                        MatchHistory.match_date <= end_date
                    )
                )
            
            # ÊåáÂÆö„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„Åõ„Å´Èñ¢„Åô„ÇãÂØæÊà¶„ÅÆ„Åø
            if len(selected_classes) == 1:
                # Âçò‰Ωì„ÇØ„É©„Çπ - ‰øÆÊ≠£Áâà
                class_name = selected_classes[0]
                query = query.filter(
                    or_(
                        # user1„ÅåÊåáÂÆö„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû
                        MatchHistory.user1_selected_class == class_name,
                        # user2„ÅåÊåáÂÆö„ÇØ„É©„Çπ„ÇíÈÅ∏Êäû
                        MatchHistory.user2_selected_class == class_name
                    )
                )
            else:
                # 2„Å§„ÅÆ„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„ÅõÔºàÊó¢Â≠ò„ÅÆ„Åæ„ÅæÔºâ
                class1, class2 = selected_classes
                query = query.filter(
                    or_(
                        # user1„ÅåÊåáÂÆö„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÁôªÈå≤
                        and_(
                            or_(
                                and_(MatchHistory.user1_class_a == class1, MatchHistory.user1_class_b == class2),
                                and_(MatchHistory.user1_class_a == class2, MatchHistory.user1_class_b == class1)
                            )
                        ),
                        # user2„ÅåÊåáÂÆö„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÁôªÈå≤
                        and_(
                            or_(
                                and_(MatchHistory.user2_class_a == class1, MatchHistory.user2_class_b == class2),
                                and_(MatchHistory.user2_class_a == class2, MatchHistory.user2_class_b == class1)
                            )
                        )
                    )
                )
            
            matches = query.all()
            
            opponent_stats = {}
            
            if len(selected_classes) == 1:
                # Âçò‰∏Ä„ÇØ„É©„ÇπÈÅ∏ÊäûÊôÇÔºö7Á®ÆÈ°û„ÅÆ„ÇØ„É©„Çπ„Åù„Çå„Åû„Çå„Å®„ÅÆÊà¶Á∏æ„ÇíÈõÜË®à
                from config.settings import VALID_CLASSES
                class_name = selected_classes[0]
                
                # ÂêÑ„ÇØ„É©„Çπ„Å´ÂØæ„Åó„Å¶Áµ±Ë®à„ÇíÂàùÊúüÂåñ
                for opponent_class in VALID_CLASSES:
                    opponent_stats[opponent_class] = {
                        'total_matches': 0,
                        'opponent_wins': 0,
                        'my_wins': 0
                    }
                
                # „Éû„ÉÉ„ÉÅ„Éá„Éº„Çø„ÇíÂàÜÊûê
                for match in matches:
                    # ÊåáÂÆö„ÇØ„É©„Çπ‰ΩøÁî®ËÄÖ„ÇíÁâπÂÆö
                    my_user_id = None
                    opponent_user_id = None
                    opponent_selected_class = None
                    
                    if match.user1_selected_class == class_name:
                        my_user_id = match.user1_id
                        opponent_user_id = match.user2_id
                        opponent_selected_class = match.user2_selected_class
                    elif match.user2_selected_class == class_name:
                        my_user_id = match.user2_id
                        opponent_user_id = match.user1_id
                        opponent_selected_class = match.user1_selected_class
                    
                    # Áµ±Ë®à„ÇíÊõ¥Êñ∞
                    if opponent_selected_class and opponent_selected_class in opponent_stats:
                        opponent_stats[opponent_selected_class]['total_matches'] += 1
                        
                        if match.winner_user_id == my_user_id:
                            opponent_stats[opponent_selected_class]['my_wins'] += 1
                        else:
                            opponent_stats[opponent_selected_class]['opponent_wins'] += 1
                
                # ÁµêÊûú„ÇíÊï¥ÂΩ¢
                result = []
                for opponent_class, stats in opponent_stats.items():
                    if stats['total_matches'] > 0:  # ÂØæÊà¶„Åå„ÅÇ„Å£„Åü„ÇØ„É©„Çπ„ÅÆ„Åø
                        win_rate = (stats['my_wins'] / stats['total_matches']) * 100
                        result.append({
                            'opponent_class_combo': opponent_class,  # Âçò‰∏Ä„ÇØ„É©„ÇπÂêç
                            'opponent_selected_class': opponent_class,
                            'total_matches': stats['total_matches'],
                            'opponent_wins': stats['opponent_wins'],
                            'my_wins': stats['my_wins'],
                            'win_rate': win_rate
                        })
                
                return result
                
            else:
                # 2„Å§„ÅÆ„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„ÅõÔºàÊó¢Â≠ò„ÅÆÂá¶ÁêÜ„Çí„Åù„ÅÆ„Åæ„ÅæÁ∂≠ÊåÅÔºâ
                # ÂÖ®„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÁîüÊàê
                from config.settings import VALID_CLASSES
                all_combinations = []
                
                # 2„Å§„ÅÆ„ÇØ„É©„Çπ„ÅÆÁµÑ„ÅøÂêà„Çè„ÅõÔºàC(7,2) = 21ÈÄö„ÇäÔºâ
                for combo in combinations(VALID_CLASSES, 2):
                    combo_key = tuple(sorted(combo))
                    all_combinations.append(combo_key)
                
                # ÂêÑÁµÑ„ÅøÂêà„Çè„Åõ„Å´ÂØæ„Åó„Å¶„ÄÅ„Å©„Å°„Çâ„ÇíÈÅ∏Êäû„Åó„Åü„Åã„ÅßÂàÜ„Åë„Çã
                for combo in all_combinations:
                    for selected_class in combo:
                        key = (combo, selected_class)
                        opponent_stats[key] = {
                            'total_matches': 0,
                            'opponent_wins': 0,
                            'my_wins': 0
                        }
                
                # „Éû„ÉÉ„ÉÅ„Éá„Éº„Çø„ÇíÂàÜÊûêÔºàÊó¢Â≠ò„ÅÆÂá¶ÁêÜÔºâ
                for match in matches:
                    # ÊåáÂÆö„ÇØ„É©„Çπ‰ΩøÁî®ËÄÖ„ÇíÁâπÂÆö
                    my_user_id = None
                    opponent_user_id = None
                    opponent_class_combo = None
                    opponent_selected_class = None
                    
                    class1, class2 = selected_classes
                    class_set = {class1, class2}
                    
                    if match.user1_class_a and match.user1_class_b:
                        user1_class_set = {match.user1_class_a, match.user1_class_b}
                    else:
                        user1_class_set = set()
                    
                    if match.user2_class_a and match.user2_class_b:
                        user2_class_set = {match.user2_class_a, match.user2_class_b}
                    else:
                        user2_class_set = set()
                    
                    if user1_class_set == class_set:
                        my_user_id = match.user1_id
                        opponent_user_id = match.user2_id
                        if match.user2_class_a and match.user2_class_b:
                            opponent_class_combo = tuple(sorted([match.user2_class_a, match.user2_class_b]))
                            opponent_selected_class = match.user2_selected_class
                    elif user2_class_set == class_set:
                        my_user_id = match.user2_id
                        opponent_user_id = match.user1_id
                        if match.user1_class_a and match.user1_class_b:
                            opponent_class_combo = tuple(sorted([match.user1_class_a, match.user1_class_b]))
                            opponent_selected_class = match.user1_selected_class
                    
                    # Áµ±Ë®à„ÇíÊõ¥Êñ∞
                    if (opponent_class_combo and opponent_selected_class and 
                        opponent_class_combo in [combo for combo, _ in opponent_stats.keys()]):
                        
                        key = (opponent_class_combo, opponent_selected_class)
                        if key in opponent_stats:
                            opponent_stats[key]['total_matches'] += 1
                            
                            if match.winner_user_id == my_user_id:
                                opponent_stats[key]['my_wins'] += 1
                            else:
                                opponent_stats[key]['opponent_wins'] += 1
                
                # ÁµêÊûú„ÇíÊï¥ÂΩ¢ÔºàÊó¢Â≠ò„ÅÆÂá¶ÁêÜÔºâ
                result = []
                for (combo, selected_class), stats in opponent_stats.items():
                    if stats['total_matches'] > 0:
                        combo_str = f"{combo[0]} + {combo[1]}"
                        win_rate = (stats['my_wins'] / stats['total_matches']) * 100
                        result.append({
                            'opponent_class_combo': combo_str,
                            'opponent_selected_class': selected_class,
                            'total_matches': stats['total_matches'],
                            'opponent_wins': stats['opponent_wins'],
                            'my_wins': stats['my_wins'],
                            'win_rate': win_rate
                        })
                
                return result
        
        # „Éá„Éº„Çø„Éô„Éº„Çπ„Ç¢„ÇØ„Çª„Çπ
        from models.match import MatchModel
        match_model = MatchModel()
        return match_model.safe_execute(_get_analysis_data) or []
    
    def create_analysis_embeds(self, analysis_data: List[Dict], class_desc: str, 
                            period_desc: str, sort_desc: str) -> List[discord.Embed]:
        """ÂàÜÊûêÁµêÊûú„ÅÆEmbed„Çí‰ΩúÊàê"""
        try:
            from config.settings import get_class_emoji, VALID_CLASSES
        except ImportError:
            # „Ç§„É≥„Éù„Éº„Éà„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            def get_class_emoji(class_name: str) -> str:
                emoji_map = {
                    "„Ç®„É´„Éï": "üßù",
                    "„É≠„Ç§„É§„É´": "üëë", 
                    "„Ç¶„Ç£„ÉÉ„ÉÅ": "üßô",
                    "„Éâ„É©„Ç¥„É≥": "üêâ",
                    "„Éä„Ç§„Éà„É°„Ç¢": "üòà",
                    "„Éì„Ç∑„Éß„ÉÉ„Éó": "‚õ™",
                    "„Éç„É°„Ç∑„Çπ": "ü§ñ"
                }
                return emoji_map.get(class_name, "üéØ")
            
            VALID_CLASSES = ['„Ç®„É´„Éï', '„É≠„Ç§„É§„É´', '„Ç¶„Ç£„ÉÉ„ÉÅ', '„Éâ„É©„Ç¥„É≥', '„Éä„Ç§„Éà„É°„Ç¢', '„Éì„Ç∑„Éß„ÉÉ„Éó', '„Éç„É°„Ç∑„Çπ']
        
        embeds = []
        
        # Âçò‰∏Ä„ÇØ„É©„ÇπÈÅ∏ÊäûÊôÇ„Å®ÁµÑ„ÅøÂêà„Çè„ÅõÈÅ∏ÊäûÊôÇ„ÅßÂá¶ÁêÜ„ÇíÂàÜ„Åë„Çã
        if "Âçò‰Ωì" in class_desc:
            # Âçò‰∏Ä„ÇØ„É©„ÇπÈÅ∏ÊäûÊôÇÔºö7Á®ÆÈ°û„ÅÆ„ÇØ„É©„ÇπÂÄãÂà•Ë°®Á§∫ÔºàÊó¢Â≠òÂá¶ÁêÜ„ÅÆ„Åæ„ÅæÔºâ
            if not analysis_data:
                embed = discord.Embed(
                    title=f"Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûê ({sort_desc})",
                    description=f"**ÂàÜÊûêÂØæË±°:** {class_desc}\n**ÊúüÈñì:** {period_desc}\n\nË©≤ÂΩì„Åô„Çã„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ",
                    color=discord.Color.orange()
                )
                return [embed]
            
            # 1„Éö„Éº„Ç∏„ÅÇ„Åü„Çä7„ÇØ„É©„ÇπË°®Á§∫
            items_per_page = 7
            
            for page_start in range(0, len(analysis_data), items_per_page):
                page_num = (page_start // items_per_page) + 1
                total_pages = (len(analysis_data) + items_per_page - 1) // items_per_page
                
                embed = discord.Embed(
                    title=f"Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûê ({sort_desc}) - Page {page_num}/{total_pages}",
                    description=f"**ÂàÜÊûêÂØæË±°:** {class_desc}\n**ÊúüÈñì:** {period_desc}",
                    color=discord.Color.green()
                )
                
                # ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó
                page_data = analysis_data[page_start:page_start + items_per_page]
                
                # ÂêÑ„ÇØ„É©„Çπ„ÅÆÊà¶Á∏æ„ÇíË°®Á§∫
                for item in page_data:
                    opponent_class = item['opponent_class_combo']  # Âçò‰∏Ä„ÇØ„É©„ÇπÂêç
                    total_matches = item['total_matches']
                    opponent_wins = item['opponent_wins']
                    my_wins = item['my_wins']
                    win_rate = item['win_rate']
                    
                    # „ÇØ„É©„ÇπÁµµÊñáÂ≠ó„ÇíÂèñÂæó
                    class_emoji = get_class_emoji(opponent_class)
                    
                    # „Ç∑„É≥„Éó„É´„Å™1Ë°åË°®Á§∫: "3Âãù - 2Êïó (60.0%)"
                    field_value = f"{my_wins}Âãù - {opponent_wins}Êïó ({win_rate:.1f}%)"
                    
                    embed.add_field(
                        name=f"{class_emoji} {opponent_class}",
                        value=field_value,
                        inline=True
                    )
                
                embeds.append(embed)
            
            return embeds
        
        else:
            # 2„Å§„ÅÆ„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„ÅõÈÅ∏ÊäûÊôÇÔºö‰øÆÊ≠£Áâà
            from itertools import combinations
            
            # ÂÖ®„ÇØ„É©„ÇπÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÁîüÊàê
            all_combinations = []
            for combo in combinations(VALID_CLASSES, 2):
                combo_key = tuple(sorted(combo))
                all_combinations.append(combo_key)
            
            # ÁµÑ„ÅøÂêà„Çè„Åõ„É¨„Éô„É´„Åß„ÅÆ„Éá„Éº„Çø„Çí‰ΩúÊàê
            combo_summary = {}
            
            # Êó¢Â≠ò„Éá„Éº„Çø„Çí„Éû„ÉÉ„Éó„Å´Â§âÊèõ
            existing_data_map = {}
            for item in analysis_data:
                combo_tuple = tuple(sorted(item['opponent_class_combo'].split(' + ')))
                selected_class = item['opponent_selected_class']
                key = (combo_tuple, selected_class)
                existing_data_map[key] = item
            
            # ÁµÑ„ÅøÂêà„Çè„Åõ„Åî„Å®„ÅÆÂêàË®à„ÇíË®àÁÆó
            for combo_tuple in all_combinations:
                combo_str = f"{combo_tuple[0]} + {combo_tuple[1]}"
                
                # ÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆÂêàË®à„Éá„Éº„Çø„ÇíË®àÁÆó
                total_my_wins = 0
                total_opponent_wins = 0
                total_matches = 0
                combo_class_data = []
                
                # ÂêÑ„ÇØ„É©„ÇπÈÅ∏Êäû„ÅÆ„Éá„Éº„Çø„ÇíÂèéÈõÜ
                for selected_class in combo_tuple:
                    key = (combo_tuple, selected_class)
                    
                    if key in existing_data_map:
                        item_data = existing_data_map[key]
                        total_my_wins += item_data['my_wins']
                        total_opponent_wins += item_data['opponent_wins']
                        total_matches += item_data['total_matches']
                        combo_class_data.append(item_data)
                    else:
                        # „Éá„Éº„Çø„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ0„Éá„Éº„Çø„Çí‰ΩúÊàê
                        zero_data = {
                            'opponent_class_combo': combo_str,
                            'opponent_selected_class': selected_class,
                            'total_matches': 0,
                            'opponent_wins': 0,
                            'my_wins': 0,
                            'win_rate': 0.0
                        }
                        combo_class_data.append(zero_data)
                
                # ÁµÑ„ÅøÂêà„Çè„Åõ„Å´Ë©¶Âêà„Åå„ÅÇ„Å£„ÅüÂ†¥Âêà„ÅÆ„ÅøËøΩÂä†
                if total_matches > 0:
                    combo_win_rate = (total_my_wins / total_matches) * 100
                    
                    # ÂêÑ„ÇØ„É©„ÇπÈÅ∏Êäû„ÇíÂãùÁéáÈ†Ü„Åß„ÇΩ„Éº„Éà
                    combo_class_data.sort(key=lambda x: (x['win_rate'], x['my_wins']), reverse=True)
                    
                    combo_summary[combo_tuple] = {
                        'combo_str': combo_str,
                        'total_my_wins': total_my_wins,
                        'total_opponent_wins': total_opponent_wins,
                        'total_matches': total_matches,
                        'combo_win_rate': combo_win_rate,
                        'class_data': combo_class_data
                    }
            
            # „Éá„Éº„Çø„ÅåÁ©∫„ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜ
            if not combo_summary:
                embed = discord.Embed(
                    title=f"Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûê ({sort_desc})",
                    description=f"**ÂàÜÊûêÂØæË±°:** {class_desc}\n**ÊúüÈñì:** {period_desc}\n\nË©≤ÂΩì„Åô„Çã„Éá„Éº„Çø„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ",
                    color=discord.Color.orange()
                )
                return [embed]
            
            # ÁµÑ„ÅøÂêà„Çè„Åõ„Çí„ÇΩ„Éº„Éà
            combo_list = list(combo_summary.values())
            if sort_desc == "ÂãùÂà©Êï∞È†Ü":
                # Ëá™ÂàÜ„ÅÆÂãùÂà©Êï∞È†ÜÔºàÂ§ö„ÅÑÈ†Ü„ÄÅÂêåÊï∞ÊôÇ„ÅØÂãùÁéáÈ†ÜÔºâ
                combo_list.sort(key=lambda x: (x['total_my_wins'], x['combo_win_rate']), reverse=True)
            else:  # ÂãùÁéáÈ†Ü
                # ÂãùÁéáÈ†ÜÔºàÈ´ò„ÅÑÈ†Ü„ÄÅÂêåÁéáÊôÇ„ÅØÂãùÂà©Êï∞È†ÜÔºâ
                combo_list.sort(key=lambda x: (x['combo_win_rate'], x['total_my_wins']), reverse=True)
            
            # „Éö„Éº„Ç∏„Åî„Å®„Å´Âá¶ÁêÜÔºà6ÁµÑÂêà„Åõ per pageÔºâ
            items_per_page = 6
            
            for page_start in range(0, len(combo_list), items_per_page):
                page_num = (page_start // items_per_page) + 1
                total_pages = (len(combo_list) + items_per_page - 1) // items_per_page
                
                embed = discord.Embed(
                    title=f"Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûê ({sort_desc}) - Page {page_num}/{total_pages}",
                    description=f"**ÂàÜÊûêÂØæË±°:** {class_desc}\n**ÊúüÈñì:** {period_desc}",
                    color=discord.Color.green()
                )
                
                # ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó
                page_combos = combo_list[page_start:page_start + items_per_page]
                
                # ÂêÑÁµÑ„ÅøÂêà„Çè„Åõ„ÇíË°®Á§∫
                for combo_data in page_combos:
                    combo_str = combo_data['combo_str']
                    total_my_wins = combo_data['total_my_wins']
                    total_opponent_wins = combo_data['total_opponent_wins']
                    combo_win_rate = combo_data['combo_win_rate']
                    class_data = combo_data['class_data']
                    
                    # „Çø„Ç§„Éà„É´Áî®„ÅÆÁµµÊñáÂ≠ó„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆÈ†ÜÁï™„ÅßÂèñÂæó
                    combo_parts = combo_str.split(' + ')
                    title_emoji1 = get_class_emoji(combo_parts[0])
                    title_emoji2 = get_class_emoji(combo_parts[1])
                    
                    # ÁµÑ„ÅøÂêà„Çè„Åõ„ÅÆ„Çø„Ç§„Éà„É´
                    combo_title = f"{title_emoji1} {combo_str} (ÂêàË®àÔºö{total_my_wins}Âãù-{total_opponent_wins}Êïó {combo_win_rate:.1f}%)"
                    
                    # ÂêÑ„ÇØ„É©„ÇπÈÅ∏Êäû„ÅÆË©≥Á¥∞
                    class_details = []
                    for class_item in class_data:
                        selected_class = class_item['opponent_selected_class']
                        my_wins = class_item['my_wins']
                        opponent_wins = class_item['opponent_wins']
                        win_rate = class_item['win_rate']
                        
                        class_details.append(f"{selected_class}ÈÅ∏Êäû: {my_wins}Âãù-{opponent_wins}Êïó {win_rate:.1f}%")
                    
                    field_value = "„Éª" + " „Éª".join(class_details)
                    
                    embed.add_field(
                        name=combo_title,
                        value=field_value,
                        inline=False
                    )
                
                embeds.append(embed)
            
            return embeds

class OpponentAnalysisPaginatorView(View):
    def __init__(self, embeds: List[discord.Embed]):
        super().__init__(timeout=600)
        self.embeds = embeds
        self.current = 0
        self.logger = logging.getLogger(self.__class__.__name__)
    
    @discord.ui.button(label="‚¨ÖÔ∏è Ââç„Å∏", style=discord.ButtonStyle.primary)
    async def previous(self, button: Button, interaction: discord.Interaction):
        """Ââç„ÅÆ„Éö„Éº„Ç∏„Å∏"""
        if self.current > 0:
            self.current -= 1
            await interaction.response.edit_message(embed=self.embeds[self.current], view=self)
        else:
            await interaction.response.defer()
    
    @discord.ui.button(label="‚û°Ô∏è Ê¨°„Å∏", style=discord.ButtonStyle.primary)
    async def next(self, button: Button, interaction: discord.Interaction):
        """Ê¨°„ÅÆ„Éö„Éº„Ç∏„Å∏"""
        if self.current < len(self.embeds) - 1:
            self.current += 1
            await interaction.response.edit_message(embed=self.embeds[self.current], view=self)
        else:
            await interaction.response.defer()
    
    @discord.ui.button(label="üî¢ „Éö„Éº„Ç∏ÊÉÖÂ†±", style=discord.ButtonStyle.secondary)
    async def page_info(self, button: Button, interaction: discord.Interaction):
        """ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏ÊÉÖÂ†±„ÇíË°®Á§∫"""
        await interaction.response.send_message(
            f"ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏: {self.current + 1} / {len(self.embeds)}", 
            ephemeral=True
        )
    
    async def on_timeout(self):
        try:
            for item in self.children:
                item.disabled = True
        except Exception as e:
            self.logger.error(f"Error in on_timeout: {e}")


class DetailedRecordView(View):
    
    def __init__(self):
        super().__init__(timeout=None)
        
        # Êó¢Â≠ò„ÅÆË©≥Á¥∞„Å™Êà¶Á∏æ„Éú„Çø„É≥
        detailed_record_button = Button(label="Ë©≥Á¥∞„Å™Êà¶Á∏æ", style=discord.ButtonStyle.success)
        async def detailed_record_callback(interaction):
            await self.show_detailed_season_select(interaction)
        detailed_record_button.callback = detailed_record_callback
        self.add_item(detailed_record_button)
        
        analysis_wins_button = Button(
            label="Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûêÔºàÂãùÂà©Êï∞È†ÜÔºâ", 
            style=discord.ButtonStyle.primary,
            emoji="üèÜ"
        )
        async def analysis_wins_callback(interaction):
            await self.show_analysis_season_select(interaction, "wins")
        analysis_wins_button.callback = analysis_wins_callback
        self.add_item(analysis_wins_button)
        
        analysis_rate_button = Button(
            label="Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûêÔºàÂãùÁéáÈ†ÜÔºâ", 
            style=discord.ButtonStyle.secondary,
            emoji="üìä"
        )
        async def analysis_rate_callback(interaction):
            await self.show_analysis_season_select(interaction, "rate")
        analysis_rate_button.callback = analysis_rate_callback
        self.add_item(analysis_rate_button)
    
    async def show_detailed_season_select(self, interaction: discord.Interaction):
        """Ë©≥Á¥∞Êà¶Á∏æ„ÅÆ„Ç∑„Éº„Ç∫„É≥ÈÅ∏Êäû„ÇíË°®Á§∫"""
        user_model = UserModel()
        user = user_model.get_user_by_discord_id(str(interaction.user.id))
        
        if not user:
            await interaction.response.send_message("„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
            return
        
        # Ë©≥Á¥∞Êà¶Á∏æÁî®„ÅÆ„Ç∑„Éº„Ç∫„É≥ÈÅ∏Êäû„ÇíË°®Á§∫
        await interaction.response.send_message(
            content="Ë©≥Á¥∞Êà¶Á∏æ„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:", 
            view=DetailedSeasonSelectView(), 
            ephemeral=True
        )
    
    async def show_analysis_season_select(self, interaction: discord.Interaction, sort_type: str):
        user_model = UserModel()
        user = user_model.get_user_by_discord_id(str(interaction.user.id))
        
        if not user:
            await interaction.response.send_message("„É¶„Éº„Ç∂„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", ephemeral=True)
            return
        
        sort_desc = "ÂãùÂà©Êï∞È†Ü" if sort_type == "wins" else "ÂãùÁéáÈ†Ü"
        await interaction.response.send_message(
            content=f"Êäï„Åí„Çâ„Çå„Åü„ÇØ„É©„ÇπÂàÜÊûêÔºà{sort_desc}Ôºâ„ÅÆ„Ç∑„Éº„Ç∫„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ:", 
            view=OpponentAnalysisSeasonSelectView(sort_type), 
            ephemeral=True
        )